// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: draft.sql

package persistence

import (
	"context"
	"database/sql"

	"demo/internal/messenger/domain"
	"github.com/gofrs/uuid"
	"github.com/lib/pq"
)

const findDraftForUpdate = `-- name: FindDraftForUpdate :one
select id, conversation_id, author_id, text, text_parts from "messenger"."draft" where id = $1 for update
`

func (q *Queries) FindDraftForUpdate(ctx context.Context, id uuid.UUID) (MessengerDraft, error) {
	row := q.db.QueryRowContext(ctx, findDraftForUpdate, id)
	var i MessengerDraft
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.AuthorID,
		&i.Text,
		&i.TextParts,
	)
	return i, err
}

const findDrafts = `-- name: FindDrafts :many
select id, conversation_id, author_id, text, text_parts
from "messenger"."draft"
where author_id = $1 and conversation_id = ANY($2::uuid[])
`

type FindDraftsParams struct {
	AuthorID        uuid.UUID
	ConversationIds []uuid.UUID
}

func (q *Queries) FindDrafts(ctx context.Context, arg FindDraftsParams) ([]MessengerDraft, error) {
	rows, err := q.db.QueryContext(ctx, findDrafts, arg.AuthorID, pq.Array(arg.ConversationIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessengerDraft
	for rows.Next() {
		var i MessengerDraft
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.AuthorID,
			&i.Text,
			&i.TextParts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOrCreateDraft = `-- name: FindOrCreateDraft :one
with new_draft as (
    insert into "messenger"."draft" (id, conversation_id, author_id)
        select $1,$2,$3
        where not exists (
            select 1 from "messenger"."draft"
            where author_id = $3 and conversation_id = $2
        )
        on conflict do nothing
        returning id, conversation_id, author_id, text, text_parts
) (
    select id, conversation_id, author_id, text, text_parts from "messenger"."draft"
    where author_id = $3 and conversation_id = $2

    union all

    select id, conversation_id, author_id, text, text_parts from new_draft
) limit 1
`

type FindOrCreateDraftParams struct {
	ID             uuid.UUID
	ConversationID uuid.UUID
	AuthorID       uuid.UUID
}

func (q *Queries) FindOrCreateDraft(ctx context.Context, arg FindOrCreateDraftParams) (MessengerDraft, error) {
	row := q.db.QueryRowContext(ctx, findOrCreateDraft, arg.ID, arg.ConversationID, arg.AuthorID)
	var i MessengerDraft
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.AuthorID,
		&i.Text,
		&i.TextParts,
	)
	return i, err
}

const removeDraft = `-- name: RemoveDraft :exec
delete from "messenger"."draft" where author_id = $1 and conversation_id = $2
`

type RemoveDraftParams struct {
	AuthorID       uuid.UUID
	ConversationID uuid.UUID
}

func (q *Queries) RemoveDraft(ctx context.Context, arg RemoveDraftParams) error {
	_, err := q.db.ExecContext(ctx, removeDraft, arg.AuthorID, arg.ConversationID)
	return err
}

const updateDraft = `-- name: UpdateDraft :exec
update "messenger"."draft" set
    text = $1,
    text_parts = $2
where id = $3
`

type UpdateDraftParams struct {
	Text      sql.NullString
	TextParts domain.RichTextParts
	ID        uuid.UUID
}

func (q *Queries) UpdateDraft(ctx context.Context, arg UpdateDraftParams) error {
	_, err := q.db.ExecContext(ctx, updateDraft, arg.Text, arg.TextParts, arg.ID)
	return err
}
