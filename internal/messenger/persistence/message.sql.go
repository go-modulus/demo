// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: message.sql

package persistence

import (
	"context"
	"database/sql"
	"time"

	"demo/internal/messenger/domain"
	"github.com/gofrs/uuid"
	"github.com/lib/pq"
)

const createMessage = `-- name: CreateMessage :exec
insert into "messenger"."message" (id, conversation_id, sender_id, text, text_parts, status, type, updated_at, created_at) values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateMessageParams struct {
	ID             uuid.UUID
	ConversationID uuid.UUID
	SenderID       uuid.UUID
	Text           sql.NullString
	TextParts      domain.RichTextParts
	Status         string
	Type           string
	UpdatedAt      time.Time
	CreatedAt      time.Time
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) error {
	_, err := q.db.ExecContext(ctx, createMessage,
		arg.ID,
		arg.ConversationID,
		arg.SenderID,
		arg.Text,
		arg.TextParts,
		arg.Status,
		arg.Type,
		arg.UpdatedAt,
		arg.CreatedAt,
	)
	return err
}

const findLastMessages = `-- name: FindLastMessages :many
select m.id, m.conversation_id, m.sender_id, m.text, m.text_parts, m.status, m.type, m.updated_at, m.created_at
from "messenger"."conversation" c
join lateral (
    select mj.id, mj.conversation_id, mj.sender_id, mj.text, mj.text_parts, mj.status, mj.type, mj.updated_at, mj.created_at from "messenger"."message" mj
    where mj.conversation_id = c.id and mj.type = 'text'
    order by mj.created_at desc
    limit 1
) m on true
where c.id = ANY($1::uuid[])
order by c.id
`

func (q *Queries) FindLastMessages(ctx context.Context, conversationIds []uuid.UUID) ([]MessengerMessage, error) {
	rows, err := q.db.QueryContext(ctx, findLastMessages, pq.Array(conversationIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessengerMessage
	for rows.Next() {
		var i MessengerMessage
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Text,
			&i.TextParts,
			&i.Status,
			&i.Type,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMessageForUpdate = `-- name: FindMessageForUpdate :one
select id, conversation_id, sender_id, text, text_parts, status, type, updated_at, created_at from "messenger"."message" where id = $1 for update
`

func (q *Queries) FindMessageForUpdate(ctx context.Context, id uuid.UUID) (MessengerMessage, error) {
	row := q.db.QueryRowContext(ctx, findMessageForUpdate, id)
	var i MessengerMessage
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Text,
		&i.TextParts,
		&i.Status,
		&i.Type,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getMessage = `-- name: GetMessage :one
select id, conversation_id, sender_id, text, text_parts, status, type, updated_at, created_at from "messenger"."message" where id = $1 limit 1
`

func (q *Queries) GetMessage(ctx context.Context, id uuid.UUID) (MessengerMessage, error) {
	row := q.db.QueryRowContext(ctx, getMessage, id)
	var i MessengerMessage
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Text,
		&i.TextParts,
		&i.Status,
		&i.Type,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const paginateMessages = `-- name: PaginateMessages :many
select id, conversation_id, sender_id, text, text_parts, status, type, updated_at, created_at from "messenger"."message"
where
  conversation_id = $1
  and (
        $2::timestamp is null
        or created_at < $2
        or ($3::uuid is null or (created_at = $2 and id > $3))
    )
order by created_at desc, id
limit $4
`

type PaginateMessagesParams struct {
	ConversationID uuid.UUID
	AfterCreatedAt sql.NullTime
	AfterID        uuid.NullUUID
	First          int32
}

func (q *Queries) PaginateMessages(ctx context.Context, arg PaginateMessagesParams) ([]MessengerMessage, error) {
	rows, err := q.db.QueryContext(ctx, paginateMessages,
		arg.ConversationID,
		arg.AfterCreatedAt,
		arg.AfterID,
		arg.First,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessengerMessage
	for rows.Next() {
		var i MessengerMessage
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Text,
			&i.TextParts,
			&i.Status,
			&i.Type,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessage = `-- name: UpdateMessage :exec
update "messenger"."message" set
    text = $1,
    text_parts = $2,
    updated_at = $3
where id = $4
`

type UpdateMessageParams struct {
	Text      sql.NullString
	TextParts domain.RichTextParts
	UpdatedAt time.Time
	ID        uuid.UUID
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) error {
	_, err := q.db.ExecContext(ctx, updateMessage,
		arg.Text,
		arg.TextParts,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
